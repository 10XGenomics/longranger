#
# Copyright (c) 2014 10X Genomics, Inc. All rights reserved.
#
@include "_structvar_caller_stages.mro"

pipeline _STRUCTVAR_CALLER(
    in  bam        input                  "PHASED, duplicate-marked, sorted aligned bam file",
    in  string     sample_id,
    in  string     sex,
    in  string     barcode_whitelist,
    in  tsv        blacklist              "barcode blacklist",
    in  bed        targets,
    in  int        target_extend,
    in  string     restrict_locus,
    in  bedpe      gt_variants,
    in  int        nx,
    in  int        window_size            "window size for BC overlap",
    in  int        step                   "step for windowing",
    in  int        min_reads              "min reads in a window - merge windows otherwise",
    in  float      max_bcs_to_call        "max BC count in a window to compute BC overlaps - used to avoid pileup regions",
    in  string     overlap_test           "type of test to use in DETECT_OVERLAPS",
    in  int        max_merge_dist         "max distance for merging windows with too few reads in COUNT_READS_BCS",
    in  bool       read1_only             "only use read1 for computing barcode overlaps",
    in  bool       slide                  "use sliding windows",
    in  int        min_mapq               "minimum mapq for read to be considered",
    in  int        min_overlap            "min BC overlap in DETECT_OVERLAPS",
    in  int        sv_min_qv              "maximum output p-value",
    in  int        sv_min_call_qv_wgs     "used to overwrite automatically computed min score in ANALYZE",
    in  int        sv_min_call_qv_target,
    in  float      p_ov_mol               "probability of barcode collisions",
    in  int        min_call_dist,
    in  int        min_read_support,
    in  string     reference_path,
    in  bed        sv_blacklist_regions   "genome region blacklist for SV calling - null will use default",
    in  bedpe      seg_dups               "null will use default",
    in  int        min_dist_from_black,
    in  float      max_frac_black,
    in  int        seg_dup_min_dist,
    in  int[]      detect_dists,
    in  int[]      target_dists,
    in  float      min_frac_overlap       "fractional overlap for merging calls",
    in  int        min_sv_len             "restrict ground truth to svs of at least this length",
    in  int        low_depth_min_len      "min candidate del based on coverage",
    in  int        min_rp_lr_to_call,
    in  float      rp_lr_multiplier       "final score = (score from CALL_STRUCTVARS) + rp_lr_multiplier * (score from GET_READPAIR_EVIDENCE)",
    in  int        min_reads_to_call      "min num of reads in GET_READPAIR_EVIDENCE to adjust breakpoints",
    in  int        rp_break_ext           "extension to apply on breakpoints before searching for read-pair support in GET_READPAIR_EVIDENCE",
    in  float      min_rel_depth,
    in  float      max_clipped_frac       "max fraction of clipped reads before considering a pileup artifact",
    in  json       insert_sizes,
    in  json       basic_summary,
    in  h5         fragments,
    in  json       fragment_histogram,
    in  tsv.gz     fragment_phasing,
    in  h5         barcodes,
    in  json       coverage_summary,
    in  csv        coverage_csv,
    in  h5         coverage,
    in  bool       is_germline,
    in  int        max_cand_breaks        "max number of refined loci per candidate to consider in CALL_STRUCTVARS",
    in  int        grid_len               "grid length for refining barcode overlap regions in CALL_STRUCTVARS",
    out bedpe      sv_calls               "called variants file",
    out bedpe      sv_candidates          "full call set with filtered calls",
    out tsv        sv_call_details,
    out vcf.gz     svs,
    out vcf.gz.tbi svs_index              "index"                   "svs.vcf.gz.tbi",
    out json       summary,
    out pickle     inv_bc_map,
    out pickle     bc_counts,
    out pickle     win_counts,
)
{
    call PREPARE_SVCALLING_RANGES(
        possorted_bam   = self.input,
        reference_path  = self.reference_path,
        coverage        = self.coverage,
        coverage_csv    = self.coverage_csv,
        min_region_len  = 100,
        region_pad      = 100,
        sex             = self.sex,
        max_bc_coverage = null,
    )

    call GET_DEL_CANDIDATES2(
        possorted_bam     = self.input,
        sex               = self.sex,
        barcode_whitelist = self.barcode_whitelist,
        reference_path    = self.reference_path,
        min_mapq          = self.min_mapq,
        min_del_len       = self.low_depth_min_len,
        max_del_len       = 500000,
        min_bad_region    = 0,
        transition_prob   = 1e-05,
        het_read_prob     = 0.9,
    )

    call GET_READPAIR_LOCI(
        possorted_bam      = self.input,
        barcode_whitelist  = self.barcode_whitelist,
        basic_summary      = self.basic_summary,
        min_mapq           = 20,
        insert_sizes       = self.insert_sizes,
        merge_range_factor = 1,
        min_reads_to_call  = self.min_reads_to_call,
        min_lr_to_call     = self.min_rp_lr_to_call,
        min_sv_len         = self.low_depth_min_len,
        max_sv_len         = 500000,
        ranges             = PREPARE_SVCALLING_RANGES.ranges,
    )

    call volatile COUNT_READS_BCS(
        input          = self.input,
        reference_path = self.reference_path,
        sex            = self.sex,
        blacklist      = self.blacklist,
        barcodes       = self.barcodes,
        inv_bc_map     = null,
        targets        = self.targets,
        target_extend  = self.target_extend,
        restrict_locus = self.restrict_locus,
        window_size    = self.window_size,
        step           = self.step,
        min_reads      = self.min_reads,
        max_merge_dist = self.max_merge_dist,
        min_mapq       = self.min_mapq,
        read1_only     = self.read1_only,
        no_split       = false,
        slide          = self.slide,
    )

    call volatile DETECT_OVERLAPS(
        possorted_bam      = self.input,
        fragment_histogram = self.fragment_histogram,
        fragments          = self.fragments,
        bc_pos_mats        = COUNT_READS_BCS.bc_pos_mats,
        inv_bc_map         = COUNT_READS_BCS.inv_bc_map,
        bc_counts          = COUNT_READS_BCS.bc_counts,
        win_counts         = COUNT_READS_BCS.win_counts,
        loci               = COUNT_READS_BCS.loci,
        nx                 = self.nx,
        min_overlap        = self.min_overlap,
        min_call_dist      = self.min_call_dist,
        max_call_dist      = 1000000000,
        max_bcs_to_call    = self.max_bcs_to_call,
        max_logp           = -15,
        test               = self.overlap_test,
    )

    call CALL_STRUCTVARS(
        possorted_bam      = self.input,
        p_ov_mol           = self.p_ov_mol,
        min_mapq           = self.min_mapq,
        min_bcs            = self.min_overlap,
        overlap_loci       = DETECT_OVERLAPS.overlap_loci,
        low_depth_loci     = GET_DEL_CANDIDATES2.del_candidates,
        rp_calls           = GET_READPAIR_LOCI.sv_calls,
        sv_min_qv          = self.sv_min_qv,
        fragments          = self.fragments,
        fragment_histogram = self.fragment_histogram,
        fragment_phasing   = self.fragment_phasing,
        barcode_blacklist  = self.blacklist,
        coverage           = self.coverage_summary,
        coverage_details   = self.coverage,
        targets            = self.targets,
        grid_len           = self.grid_len,
        max_cand_breaks    = self.max_cand_breaks,
    )

    call volatile GET_READPAIR_EVIDENCE(
        input             = self.input,
        sv_variants       = CALL_STRUCTVARS.sv_variants,
        break_extend      = self.rp_break_ext,
        min_mapq          = self.min_mapq,
        min_reads_to_call = self.min_reads_to_call,
        min_lr_to_call    = self.min_rp_lr_to_call,
        rp_lr_multiplier  = self.rp_lr_multiplier,
        insert_sizes      = self.insert_sizes,
        basic_summary     = self.basic_summary,
        best_only         = true,
    )

    call volatile MERGE_SV_CALLS(
        sv_variants1     = GET_READPAIR_EVIDENCE.sv_variants,
        sv_variants2     = null,
        max_dist         = self.window_size,
        min_frac_overlap = self.min_frac_overlap,
        merge_dist       = false,
        min_bc_overlap   = null,
    )

    call FILTER_PILEUPS(
        possorted_bam    = self.input,
        sv_calls         = MERGE_SV_CALLS.sv_variants,
        hap_coverage     = self.coverage,
        min_rel_depth    = self.min_rel_depth,
        max_clipped_frac = self.max_clipped_frac,
    )

    call ANALYZE_SV_CALLS(
        sample_id            = self.sample_id,
        variants             = FILTER_PILEUPS.sv_calls,
        gt_variants          = self.gt_variants,
        call_summary         = null,
        keep_filters         = false,
        coverage             = self.coverage_summary,
        min_call_qv_wgs      = self.sv_min_call_qv_wgs,
        min_call_qv_target   = self.sv_min_call_qv_target,
        min_read_support     = self.min_read_support,
        reference_path       = self.reference_path,
        sv_blacklist_regions = self.sv_blacklist_regions,
        seg_dups             = self.seg_dups,
        min_dist_from_black  = self.min_dist_from_black,
        max_frac_black       = self.max_frac_black,
        seg_dup_min_dist     = self.seg_dup_min_dist,
        detect_dists         = self.detect_dists,
        targets              = self.targets,
        target_dists         = self.target_dists,
        min_sv_len           = self.min_sv_len,
        min_rel_overlap      = null,
        min_allelic_frac     = null,
        is_germline          = self.is_germline,
        max_bc_cov_factor    = 3,
        blacklist_mode       = "sv",
        segdup_mode          = "sv",
    )

    return (
        sv_calls        = ANALYZE_SV_CALLS.sv_calls,
        sv_candidates   = ANALYZE_SV_CALLS.sv_candidates,
        svs             = ANALYZE_SV_CALLS.svs,
        svs_index       = ANALYZE_SV_CALLS.svs_index,
        sv_call_details = ANALYZE_SV_CALLS.call_tsv,
        summary         = ANALYZE_SV_CALLS.summary,
        inv_bc_map      = COUNT_READS_BCS.inv_bc_map,
        bc_counts       = COUNT_READS_BCS.bc_counts,
        win_counts      = COUNT_READS_BCS.win_counts,
    )
}
